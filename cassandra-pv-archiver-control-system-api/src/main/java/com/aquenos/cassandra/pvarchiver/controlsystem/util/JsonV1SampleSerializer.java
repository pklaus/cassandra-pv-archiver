/*
 * Copyright 2016 aquenos GmbH.
 * All rights reserved.
 * 
 * This program and the accompanying materials are made available under the 
 * terms of the Eclipse Public License v1.0 which accompanies this distribution,
 * and is available at http://www.eclipse.org/legal/epl-v10.html.
 */

package com.aquenos.cassandra.pvarchiver.controlsystem.util;

import java.io.IOException;

import com.aquenos.cassandra.pvarchiver.controlsystem.ControlSystemSupport;
import com.fasterxml.jackson.core.JsonGenerator;

/**
 * Utility for serializing samples in the JSON format version 1. This utility
 * should be used by implementations of
 * {@link ControlSystemSupport#serializeSampleToJsonV1(com.aquenos.cassandra.pvarchiver.controlsystem.Sample, JsonGenerator)}
 * in order to ensure that the serialized form matches the expected format.
 * 
 * @author Sebastian Marsching
 */
public abstract class JsonV1SampleSerializer {

    /**
     * Sample quality. A sample may be {@link #ORIGINAL} (it has been retrieved
     * from the control system like this) or it may be {@link #INTERPOLATED} (it
     * has been calculated by combining several original samples).
     * 
     * @author Sebastian Marsching
     */
    public static enum Quality {

        /**
         * Original sample. The sample has been retrieved from the
         * control-system like this.
         */
        ORIGINAL,

        /**
         * Interpolated sample. The sample has been generated by combining
         * several original or interpolated samples in a certain time interval.
         */
        INTERPOLATED;

    }

    /**
     * Alarm severity associated with a sample. The alarm severity signals
     * whether an alarm condition was present when the sample was archived and
     * the level of this alarm condition.
     * 
     * @author Sebastian Marsching
     */
    public static enum Severity {

        /**
         * OK. Typically, this means that there was no alarm condition present
         * when the sample was archived.
         */
        OK,

        /**
         * Minor alarm. Typically, this means that a minor alarm condition (e.g.
         * a warning) was present when the sample was archived.
         */
        MINOR,

        /**
         * Major alarm. Typically, this means that a major alarm condition (e.g.
         * an alarm indicating a serious problem) was present when the sample
         * was archived.
         */
        MAJOR,

        /**
         * Invalid alarm. Typically, this indicates that the alarm status (and
         * possibly also the value) of the archived process variable was unknown
         * when the sample was archived. For example, such an alarm condition
         * might be present when the connection to the sub-system hosting the
         * process variable is interrupted.
         */
        INVALID;

    }

    private JsonV1SampleSerializer() {
    }

    /**
     * Serializes a scalar double sample without additional meta-data.
     * 
     * @param jsonGenerator
     *            JSON generator to which the serialized data is written.
     * @param timeStamp
     *            time stamp of the sample. The time stamp is specified in
     *            nanoseconds since epoch (January 1st, 1970, 00:00:00 UTC).
     * @param value
     *            actual value of the sample.
     * @param severity
     *            alarm severity associated with the sample.
     * @param hasValue
     *            <code>true</code> if the sample has a (valid) value,
     *            <code>false</code> if the value should be ignored (possibly
     *            because it is invalid).
     * @param status
     *            status of the sample. Typically, this string contains
     *            additional information about the alarm conditions that were
     *            present when the sample was archived.
     * @param quality
     *            quality of the sample. The quality specifies whether the
     *            sample was retrieved directly from the control-system or
     *            whether it was calculated by aggregating the samples for a
     *            certain period of time.
     * @throws IOException
     *             if the <code>jsonGenerator</code> throws such an exception.
     */
    public static void serializeDoubleSample(JsonGenerator jsonGenerator,
            long timeStamp, double value, Severity severity, boolean hasValue,
            String status, Quality quality) throws IOException {
        writeCommonMetaData(jsonGenerator, timeStamp, severity, hasValue,
                status, quality);
        writeDoubleValue(jsonGenerator, value, "double");
    }

    /**
     * Serializes a scalar double sample with additional meta-data.
     * 
     * @param jsonGenerator
     *            JSON generator to which the serialized data is written.
     * @param timeStamp
     *            time stamp of the sample. The time stamp is specified in
     *            nanoseconds since epoch (January 1st, 1970, 00:00:00 UTC).
     * @param value
     *            actual value of the sample.
     * @param severity
     *            alarm severity associated with the sample.
     * @param hasValue
     *            <code>true</code> if the sample has a (valid) value,
     *            <code>false</code> if the value should be ignored (possibly
     *            because it is invalid).
     * @param status
     *            status of the sample. Typically, this string contains
     *            additional information about the alarm conditions that were
     *            present when the sample was archived.
     * @param quality
     *            quality of the sample. The quality specifies whether the
     *            sample was retrieved directly from the control-system or
     *            whether it was calculated by aggregating the samples for a
     *            certain period of time.
     * @param precision
     *            display precision of the sample's value. The precision
     *            specifies the number of fractional digits that should be
     *            displayed.
     * @param units
     *            engineering units of the sample's value.
     * @param displayLow
     *            lower display limit for the sample's value.
     * @param displayHigh
     *            upper display limit for the sample's value.
     * @param warnLow
     *            lower warning limit for the sample's value. Typically, this is
     *            the limit below which the process variable is considered to be
     *            in a minor alarm condition.
     * @param warnHigh
     *            upper warning limit for the sample's value. Typically, this is
     *            the limit above which the process variable is considered to be
     *            in a minor alarm condition.
     * @param alarmLow
     *            lower alarm limit for the sample's value. Typically, this is
     *            the limit below which the process variable is considered to be
     *            in a major alarm condition.
     * @param alarmHigh
     *            upper alarm limit for the sample's value. Typically, this is
     *            the limit above which the process variable is considered to be
     *            in a major alarm condition.
     * @throws IOException
     *             if the <code>jsonGenerator</code> throws such an exception.
     */
    public static void serializeDoubleSample(JsonGenerator jsonGenerator,
            long timeStamp, double value, Severity severity, boolean hasValue,
            String status, Quality quality, int precision, String units,
            double displayLow, double displayHigh, double warnLow,
            double warnHigh, double alarmLow, double alarmHigh)
            throws IOException {
        writeCommonMetaData(jsonGenerator, timeStamp, severity, hasValue,
                status, quality);
        writeNumericMetaData(jsonGenerator, precision, units, displayLow,
                displayHigh, warnLow, warnHigh, alarmLow, alarmHigh);
        writeDoubleValue(jsonGenerator, value, "double");
    }

    /**
     * Serializes an array double sample without additional meta-data.
     * 
     * @param jsonGenerator
     *            JSON generator to which the serialized data is written.
     * @param timeStamp
     *            time stamp of the sample. The time stamp is specified in
     *            nanoseconds since epoch (January 1st, 1970, 00:00:00 UTC).
     * @param value
     *            actual value of the sample. The array may contain zero, one,
     *            or more elements.
     * @param severity
     *            alarm severity associated with the sample.
     * @param hasValue
     *            <code>true</code> if the sample has a (valid) value,
     *            <code>false</code> if the value should be ignored (possibly
     *            because it is invalid).
     * @param status
     *            status of the sample. Typically, this string contains
     *            additional information about the alarm conditions that were
     *            present when the sample was archived.
     * @param quality
     *            quality of the sample. The quality specifies whether the
     *            sample was retrieved directly from the control-system or
     *            whether it was calculated by aggregating the samples for a
     *            certain period of time.
     * @throws IOException
     *             if the <code>jsonGenerator</code> throws such an exception.
     */
    public static void serializeDoubleSample(JsonGenerator jsonGenerator,
            long timeStamp, double[] value, Severity severity,
            boolean hasValue, String status, Quality quality)
            throws IOException {
        writeCommonMetaData(jsonGenerator, timeStamp, severity, hasValue,
                status, quality);
        writeDoubleValue(jsonGenerator, value, "double");
    }

    /**
     * Serializes an array double sample with additional meta-data.
     * 
     * @param jsonGenerator
     *            JSON generator to which the serialized data is written.
     * @param timeStamp
     *            time stamp of the sample. The time stamp is specified in
     *            nanoseconds since epoch (January 1st, 1970, 00:00:00 UTC).
     * @param value
     *            actual value of the sample. The array may contain zero, one,
     *            or more elements.
     * @param severity
     *            alarm severity associated with the sample.
     * @param hasValue
     *            <code>true</code> if the sample has a (valid) value,
     *            <code>false</code> if the value should be ignored (possibly
     *            because it is invalid).
     * @param status
     *            status of the sample. Typically, this string contains
     *            additional information about the alarm conditions that were
     *            present when the sample was archived.
     * @param quality
     *            quality of the sample. The quality specifies whether the
     *            sample was retrieved directly from the control-system or
     *            whether it was calculated by aggregating the samples for a
     *            certain period of time.
     * @param precision
     *            display precision of the sample's value. The precision
     *            specifies the number of fractional digits that should be
     *            displayed.
     * @param units
     *            engineering units of the sample's value.
     * @param displayLow
     *            lower display limit for the sample's value.
     * @param displayHigh
     *            upper display limit for the sample's value.
     * @param warnLow
     *            lower warning limit for the sample's value. Typically, this is
     *            the limit below which the process variable is considered to be
     *            in a minor alarm condition.
     * @param warnHigh
     *            upper warning limit for the sample's value. Typically, this is
     *            the limit above which the process variable is considered to be
     *            in a minor alarm condition.
     * @param alarmLow
     *            lower alarm limit for the sample's value. Typically, this is
     *            the limit below which the process variable is considered to be
     *            in a major alarm condition.
     * @param alarmHigh
     *            upper alarm limit for the sample's value. Typically, this is
     *            the limit above which the process variable is considered to be
     *            in a major alarm condition.
     * @throws IOException
     *             if the <code>jsonGenerator</code> throws such an exception.
     */
    public static void serializeDoubleSample(JsonGenerator jsonGenerator,
            long timeStamp, double[] value, Severity severity,
            boolean hasValue, String status, Quality quality, int precision,
            String units, double displayLow, double displayHigh,
            double warnLow, double warnHigh, double alarmLow, double alarmHigh)
            throws IOException {
        writeCommonMetaData(jsonGenerator, timeStamp, severity, hasValue,
                status, quality);
        writeNumericMetaData(jsonGenerator, precision, units, displayLow,
                displayHigh, warnLow, warnHigh, alarmLow, alarmHigh);
        writeDoubleValue(jsonGenerator, value, "double");
    }

    /**
     * Serializes a scalar enum sample without additional meta-data.
     * 
     * @param jsonGenerator
     *            JSON generator to which the serialized data is written.
     * @param timeStamp
     *            time stamp of the sample. The time stamp is specified in
     *            nanoseconds since epoch (January 1st, 1970, 00:00:00 UTC).
     * @param value
     *            actual value of the sample.
     * @param severity
     *            alarm severity associated with the sample.
     * @param hasValue
     *            <code>true</code> if the sample has a (valid) value,
     *            <code>false</code> if the value should be ignored (possibly
     *            because it is invalid).
     * @param status
     *            status of the sample. Typically, this string contains
     *            additional information about the alarm conditions that were
     *            present when the sample was archived.
     * @param quality
     *            quality of the sample. The quality specifies whether the
     *            sample was retrieved directly from the control-system or
     *            whether it was calculated by aggregating the samples for a
     *            certain period of time.
     * @throws IOException
     *             if the <code>jsonGenerator</code> throws such an exception.
     */
    public static void serializeEnumSample(JsonGenerator jsonGenerator,
            long timeStamp, int value, Severity severity, boolean hasValue,
            String status, Quality quality) throws IOException {
        writeCommonMetaData(jsonGenerator, timeStamp, severity, hasValue,
                status, quality);
        writeEnumValue(jsonGenerator, value);
    }

    /**
     * Serializes a scalar enum sample with additional meta-data.
     * 
     * @param jsonGenerator
     *            JSON generator to which the serialized data is written.
     * @param timeStamp
     *            time stamp of the sample. The time stamp is specified in
     *            nanoseconds since epoch (January 1st, 1970, 00:00:00 UTC).
     * @param value
     *            actual value of the sample.
     * @param severity
     *            alarm severity associated with the sample.
     * @param hasValue
     *            <code>true</code> if the sample has a (valid) value,
     *            <code>false</code> if the value should be ignored (possibly
     *            because it is invalid).
     * @param status
     *            status of the sample. Typically, this string contains
     *            additional information about the alarm conditions that were
     *            present when the sample was archived.
     * @param quality
     *            quality of the sample. The quality specifies whether the
     *            sample was retrieved directly from the control-system or
     *            whether it was calculated by aggregating the samples for a
     *            certain period of time.
     * @param states
     *            labels associated with the enum states. The specified
     *            <code>value</code> serves as an index into this array.
     * @throws IOException
     *             if the <code>jsonGenerator</code> throws such an exception.
     */
    public static void serializeEnumSample(JsonGenerator jsonGenerator,
            long timeStamp, int value, Severity severity, boolean hasValue,
            String status, Quality quality, String[] states) throws IOException {
        writeCommonMetaData(jsonGenerator, timeStamp, severity, hasValue,
                status, quality);
        writeEnumMetaData(jsonGenerator, states);
        writeEnumValue(jsonGenerator, value);
    }

    /**
     * Serializes an array enum sample without additional meta-data.
     * 
     * @param jsonGenerator
     *            JSON generator to which the serialized data is written.
     * @param timeStamp
     *            time stamp of the sample. The time stamp is specified in
     *            nanoseconds since epoch (January 1st, 1970, 00:00:00 UTC).
     * @param value
     *            actual value of the sample. The array may contain zero, one,
     *            or more elements.
     * @param severity
     *            alarm severity associated with the sample.
     * @param hasValue
     *            <code>true</code> if the sample has a (valid) value,
     *            <code>false</code> if the value should be ignored (possibly
     *            because it is invalid).
     * @param status
     *            status of the sample. Typically, this string contains
     *            additional information about the alarm conditions that were
     *            present when the sample was archived.
     * @param quality
     *            quality of the sample. The quality specifies whether the
     *            sample was retrieved directly from the control-system or
     *            whether it was calculated by aggregating the samples for a
     *            certain period of time.
     * @throws IOException
     *             if the <code>jsonGenerator</code> throws such an exception.
     */
    public static void serializeEnumSample(JsonGenerator jsonGenerator,
            long timeStamp, int[] value, Severity severity, boolean hasValue,
            String status, Quality quality) throws IOException {
        writeCommonMetaData(jsonGenerator, timeStamp, severity, hasValue,
                status, quality);
        writeEnumValue(jsonGenerator, value);
    }

    /**
     * Serializes an array enum sample without additional meta-data.
     * 
     * @param jsonGenerator
     *            JSON generator to which the serialized data is written.
     * @param timeStamp
     *            time stamp of the sample. The time stamp is specified in
     *            nanoseconds since epoch (January 1st, 1970, 00:00:00 UTC).
     * @param value
     *            actual value of the sample. The array may contain zero, one,
     *            or more elements.
     * @param severity
     *            alarm severity associated with the sample.
     * @param hasValue
     *            <code>true</code> if the sample has a (valid) value,
     *            <code>false</code> if the value should be ignored (possibly
     *            because it is invalid).
     * @param status
     *            status of the sample. Typically, this string contains
     *            additional information about the alarm conditions that were
     *            present when the sample was archived.
     * @param quality
     *            quality of the sample. The quality specifies whether the
     *            sample was retrieved directly from the control-system or
     *            whether it was calculated by aggregating the samples for a
     *            certain period of time.
     * @param states
     *            labels associated with the enum states. The specified
     *            <code>value</code> serves as an index into this array.
     * @throws IOException
     *             if the <code>jsonGenerator</code> throws such an exception.
     */
    public static void serializeEnumSample(JsonGenerator jsonGenerator,
            long timeStamp, int[] value, Severity severity, boolean hasValue,
            String status, Quality quality, String[] states) throws IOException {
        writeCommonMetaData(jsonGenerator, timeStamp, severity, hasValue,
                status, quality);
        writeEnumMetaData(jsonGenerator, states);
        writeEnumValue(jsonGenerator, value);
    }

    /**
     * Serializes a scalar long sample without additional meta-data.
     * 
     * @param jsonGenerator
     *            JSON generator to which the serialized data is written.
     * @param timeStamp
     *            time stamp of the sample. The time stamp is specified in
     *            nanoseconds since epoch (January 1st, 1970, 00:00:00 UTC).
     * @param value
     *            actual value of the sample.
     * @param severity
     *            alarm severity associated with the sample.
     * @param hasValue
     *            <code>true</code> if the sample has a (valid) value,
     *            <code>false</code> if the value should be ignored (possibly
     *            because it is invalid).
     * @param status
     *            status of the sample. Typically, this string contains
     *            additional information about the alarm conditions that were
     *            present when the sample was archived.
     * @param quality
     *            quality of the sample. The quality specifies whether the
     *            sample was retrieved directly from the control-system or
     *            whether it was calculated by aggregating the samples for a
     *            certain period of time.
     * @throws IOException
     *             if the <code>jsonGenerator</code> throws such an exception.
     */
    public static void serializeLongSample(JsonGenerator jsonGenerator,
            long timeStamp, long value, Severity severity, boolean hasValue,
            String status, Quality quality) throws IOException {
        writeCommonMetaData(jsonGenerator, timeStamp, severity, hasValue,
                status, quality);
        writeLongValue(jsonGenerator, value);
    }

    /**
     * Serializes a scalar long sample with additional meta-data.
     * 
     * @param jsonGenerator
     *            JSON generator to which the serialized data is written.
     * @param timeStamp
     *            time stamp of the sample. The time stamp is specified in
     *            nanoseconds since epoch (January 1st, 1970, 00:00:00 UTC).
     * @param value
     *            actual value of the sample.
     * @param severity
     *            alarm severity associated with the sample.
     * @param hasValue
     *            <code>true</code> if the sample has a (valid) value,
     *            <code>false</code> if the value should be ignored (possibly
     *            because it is invalid).
     * @param status
     *            status of the sample. Typically, this string contains
     *            additional information about the alarm conditions that were
     *            present when the sample was archived.
     * @param quality
     *            quality of the sample. The quality specifies whether the
     *            sample was retrieved directly from the control-system or
     *            whether it was calculated by aggregating the samples for a
     *            certain period of time.
     * @param precision
     *            display precision of the sample's value. The precision
     *            specifies the number of fractional digits that should be
     *            displayed.
     * @param units
     *            engineering units of the sample's value.
     * @param displayLow
     *            lower display limit for the sample's value.
     * @param displayHigh
     *            upper display limit for the sample's value.
     * @param warnLow
     *            lower warning limit for the sample's value. Typically, this is
     *            the limit below which the process variable is considered to be
     *            in a minor alarm condition.
     * @param warnHigh
     *            upper warning limit for the sample's value. Typically, this is
     *            the limit above which the process variable is considered to be
     *            in a minor alarm condition.
     * @param alarmLow
     *            lower alarm limit for the sample's value. Typically, this is
     *            the limit below which the process variable is considered to be
     *            in a major alarm condition.
     * @param alarmHigh
     *            upper alarm limit for the sample's value. Typically, this is
     *            the limit above which the process variable is considered to be
     *            in a major alarm condition.
     * @throws IOException
     *             if the <code>jsonGenerator</code> throws such an exception.
     */
    public static void serializeLongSample(JsonGenerator jsonGenerator,
            long timeStamp, long value, Severity severity, boolean hasValue,
            String status, Quality quality, int precision, String units,
            double displayLow, double displayHigh, double warnLow,
            double warnHigh, double alarmLow, double alarmHigh)
            throws IOException {
        writeCommonMetaData(jsonGenerator, timeStamp, severity, hasValue,
                status, quality);
        writeNumericMetaData(jsonGenerator, precision, units, displayLow,
                displayHigh, warnLow, warnHigh, alarmLow, alarmHigh);
        writeLongValue(jsonGenerator, value);
    }

    /**
     * Serializes an array long sample without additional meta-data.
     * 
     * @param jsonGenerator
     *            JSON generator to which the serialized data is written.
     * @param timeStamp
     *            time stamp of the sample. The time stamp is specified in
     *            nanoseconds since epoch (January 1st, 1970, 00:00:00 UTC).
     * @param value
     *            actual value of the sample. The array may contain zero, one,
     *            or more elements.
     * @param severity
     *            alarm severity associated with the sample.
     * @param hasValue
     *            <code>true</code> if the sample has a (valid) value,
     *            <code>false</code> if the value should be ignored (possibly
     *            because it is invalid).
     * @param status
     *            status of the sample. Typically, this string contains
     *            additional information about the alarm conditions that were
     *            present when the sample was archived.
     * @param quality
     *            quality of the sample. The quality specifies whether the
     *            sample was retrieved directly from the control-system or
     *            whether it was calculated by aggregating the samples for a
     *            certain period of time.
     * @throws IOException
     *             if the <code>jsonGenerator</code> throws such an exception.
     */
    public static void serializeLongSample(JsonGenerator jsonGenerator,
            long timeStamp, long[] value, Severity severity, boolean hasValue,
            String status, Quality quality) throws IOException {
        writeCommonMetaData(jsonGenerator, timeStamp, severity, hasValue,
                status, quality);
        writeLongValue(jsonGenerator, value);
    }

    /**
     * Serializes an array long sample with additional meta-data.
     * 
     * @param jsonGenerator
     *            JSON generator to which the serialized data is written.
     * @param timeStamp
     *            time stamp of the sample. The time stamp is specified in
     *            nanoseconds since epoch (January 1st, 1970, 00:00:00 UTC).
     * @param value
     *            actual value of the sample. The array may contain zero, one,
     *            or more elements.
     * @param severity
     *            alarm severity associated with the sample.
     * @param hasValue
     *            <code>true</code> if the sample has a (valid) value,
     *            <code>false</code> if the value should be ignored (possibly
     *            because it is invalid).
     * @param status
     *            status of the sample. Typically, this string contains
     *            additional information about the alarm conditions that were
     *            present when the sample was archived.
     * @param quality
     *            quality of the sample. The quality specifies whether the
     *            sample was retrieved directly from the control-system or
     *            whether it was calculated by aggregating the samples for a
     *            certain period of time.
     * @param precision
     *            display precision of the sample's value. The precision
     *            specifies the number of fractional digits that should be
     *            displayed.
     * @param units
     *            engineering units of the sample's value.
     * @param displayLow
     *            lower display limit for the sample's value.
     * @param displayHigh
     *            upper display limit for the sample's value.
     * @param warnLow
     *            lower warning limit for the sample's value. Typically, this is
     *            the limit below which the process variable is considered to be
     *            in a minor alarm condition.
     * @param warnHigh
     *            upper warning limit for the sample's value. Typically, this is
     *            the limit above which the process variable is considered to be
     *            in a minor alarm condition.
     * @param alarmLow
     *            lower alarm limit for the sample's value. Typically, this is
     *            the limit below which the process variable is considered to be
     *            in a major alarm condition.
     * @param alarmHigh
     *            upper alarm limit for the sample's value. Typically, this is
     *            the limit above which the process variable is considered to be
     *            in a major alarm condition.
     * @throws IOException
     *             if the <code>jsonGenerator</code> throws such an exception.
     */
    public static void serializeLongSample(JsonGenerator jsonGenerator,
            long timeStamp, long[] value, Severity severity, boolean hasValue,
            String status, Quality quality, int precision, String units,
            double displayLow, double displayHigh, double warnLow,
            double warnHigh, double alarmLow, double alarmHigh)
            throws IOException {
        writeCommonMetaData(jsonGenerator, timeStamp, severity, hasValue,
                status, quality);
        writeNumericMetaData(jsonGenerator, precision, units, displayLow,
                displayHigh, warnLow, warnHigh, alarmLow, alarmHigh);
        writeLongValue(jsonGenerator, value);
    }

    /**
     * Serializes a scalar min-max double sample without additional meta-data.
     * Typically, a min-max double sample is used for interpolated samples. For
     * such a sample, the <code>value</code> is the mean of the aggregated
     * samples' values and <code>minimum</code> and <code>maximum</code> specify
     * the interval which contains all of the aggregated samples' values.
     * 
     * @param jsonGenerator
     *            JSON generator to which the serialized data is written.
     * @param timeStamp
     *            time stamp of the sample. The time stamp is specified in
     *            nanoseconds since epoch (January 1st, 1970, 00:00:00 UTC).
     * @param value
     *            actual value of the sample. For an interpolated sample, this
     *            typically is the mean of the aggregated samples' values.
     * @param minimum
     *            minimum value. For an interpolated sample, this is typically
     *            the smallest value that any of the aggregated samples had.
     * @param maximum
     *            maximum value. For an interpolated sample, this is typically
     *            the largest value that any of the aggregated samples had.
     * @param severity
     *            alarm severity associated with the sample.
     * @param hasValue
     *            <code>true</code> if the sample has a (valid) value,
     *            <code>false</code> if the value should be ignored (possibly
     *            because it is invalid).
     * @param status
     *            status of the sample. Typically, this string contains
     *            additional information about the alarm conditions that were
     *            present when the sample was archived.
     * @param quality
     *            quality of the sample. The quality specifies whether the
     *            sample was retrieved directly from the control-system or
     *            whether it was calculated by aggregating the samples for a
     *            certain period of time.
     * @throws IOException
     *             if the <code>jsonGenerator</code> throws such an exception.
     */
    public static void serializeMinMaxDoubleSample(JsonGenerator jsonGenerator,
            long timeStamp, double value, double minimum, double maximum,
            Severity severity, boolean hasValue, String status, Quality quality)
            throws IOException {
        writeCommonMetaData(jsonGenerator, timeStamp, severity, hasValue,
                status, quality);
        writeDoubleValue(jsonGenerator, value, "minMaxDouble");
        writeMinimumMaximum(jsonGenerator, minimum, maximum);
    }

    /**
     * Serializes a scalar min-max double sample with additional meta-data.
     * Typically, a min-max double sample is used for interpolated samples. For
     * such a sample, the <code>value</code> is the mean of the aggregated
     * samples' values and <code>minimum</code> and <code>maximum</code> specify
     * the interval which contains all of the aggregated samples' values.
     * 
     * @param jsonGenerator
     *            JSON generator to which the serialized data is written.
     * @param timeStamp
     *            time stamp of the sample. The time stamp is specified in
     *            nanoseconds since epoch (January 1st, 1970, 00:00:00 UTC).
     * @param value
     *            actual value of the sample. For an interpolated sample, this
     *            typically is the mean of the aggregated samples' values.
     * @param minimum
     *            minimum value. For an interpolated sample, this is typically
     *            the smallest value that any of the aggregated samples had.
     * @param maximum
     *            maximum value. For an interpolated sample, this is typically
     *            the largest value that any of the aggregated samples had.
     * @param severity
     *            alarm severity associated with the sample.
     * @param hasValue
     *            <code>true</code> if the sample has a (valid) value,
     *            <code>false</code> if the value should be ignored (possibly
     *            because it is invalid).
     * @param status
     *            status of the sample. Typically, this string contains
     *            additional information about the alarm conditions that were
     *            present when the sample was archived.
     * @param quality
     *            quality of the sample. The quality specifies whether the
     *            sample was retrieved directly from the control-system or
     *            whether it was calculated by aggregating the samples for a
     *            certain period of time.
     * @param precision
     *            display precision of the sample's value. The precision
     *            specifies the number of fractional digits that should be
     *            displayed.
     * @param units
     *            engineering units of the sample's value.
     * @param displayLow
     *            lower display limit for the sample's value.
     * @param displayHigh
     *            upper display limit for the sample's value.
     * @param warnLow
     *            lower warning limit for the sample's value. Typically, this is
     *            the limit below which the process variable is considered to be
     *            in a minor alarm condition.
     * @param warnHigh
     *            upper warning limit for the sample's value. Typically, this is
     *            the limit above which the process variable is considered to be
     *            in a minor alarm condition.
     * @param alarmLow
     *            lower alarm limit for the sample's value. Typically, this is
     *            the limit below which the process variable is considered to be
     *            in a major alarm condition.
     * @param alarmHigh
     *            upper alarm limit for the sample's value. Typically, this is
     *            the limit above which the process variable is considered to be
     *            in a major alarm condition.
     * @throws IOException
     *             if the <code>jsonGenerator</code> throws such an exception.
     */
    public static void serializeMinMaxDoubleSample(JsonGenerator jsonGenerator,
            long timeStamp, double value, double minimum, double maximum,
            Severity severity, boolean hasValue, String status,
            Quality quality, int precision, String units, double displayLow,
            double displayHigh, double warnLow, double warnHigh,
            double alarmLow, double alarmHigh) throws IOException {
        writeCommonMetaData(jsonGenerator, timeStamp, severity, hasValue,
                status, quality);
        writeNumericMetaData(jsonGenerator, precision, units, displayLow,
                displayHigh, warnLow, warnHigh, alarmLow, alarmHigh);
        writeDoubleValue(jsonGenerator, value, "minMaxDouble");
        writeMinimumMaximum(jsonGenerator, minimum, maximum);
    }

    /**
     * Serializes an array min-max double sample without additional meta-data.
     * Typically, a min-max double sample is used for interpolated samples. For
     * such a sample, the <code>value</code> is the mean of the aggregated
     * samples' values and <code>minimum</code> and <code>maximum</code> specify
     * the interval which contains all of the aggregated samples' values.
     * 
     * @param jsonGenerator
     *            JSON generator to which the serialized data is written.
     * @param timeStamp
     *            time stamp of the sample. The time stamp is specified in
     *            nanoseconds since epoch (January 1st, 1970, 00:00:00 UTC).
     * @param value
     *            actual value of the sample. The array may contain zero, one,
     *            or more elements. For an interpolated sample, this typically
     *            is the (element-wise) mean of the aggregated samples' values.
     * @param minimum
     *            minimum value. For an interpolated sample, this is typically
     *            the smallest value that any of the aggregated samples had.
     * @param maximum
     *            maximum value. For an interpolated sample, this is typically
     *            the largest value that any of the aggregated samples had.
     * @param severity
     *            alarm severity associated with the sample.
     * @param hasValue
     *            <code>true</code> if the sample has a (valid) value,
     *            <code>false</code> if the value should be ignored (possibly
     *            because it is invalid).
     * @param status
     *            status of the sample. Typically, this string contains
     *            additional information about the alarm conditions that were
     *            present when the sample was archived.
     * @param quality
     *            quality of the sample. The quality specifies whether the
     *            sample was retrieved directly from the control-system or
     *            whether it was calculated by aggregating the samples for a
     *            certain period of time.
     * @throws IOException
     *             if the <code>jsonGenerator</code> throws such an exception.
     */
    public static void serializeMinMaxDoubleSample(JsonGenerator jsonGenerator,
            long timeStamp, double[] value, double minimum, double maximum,
            Severity severity, boolean hasValue, String status, Quality quality)
            throws IOException {
        writeCommonMetaData(jsonGenerator, timeStamp, severity, hasValue,
                status, quality);
        writeDoubleValue(jsonGenerator, value, "minMaxDouble");
        writeMinimumMaximum(jsonGenerator, minimum, maximum);
    }

    /**
     * Serializes an array min-max double sample with additional meta-data.
     * Typically, a min-max double sample is used for interpolated samples. For
     * such a sample, the <code>value</code> is the mean of the aggregated
     * samples' values and <code>minimum</code> and <code>maximum</code> specify
     * the interval which contains all of the aggregated samples' values.
     * 
     * @param jsonGenerator
     *            JSON generator to which the serialized data is written.
     * @param timeStamp
     *            time stamp of the sample. The time stamp is specified in
     *            nanoseconds since epoch (January 1st, 1970, 00:00:00 UTC).
     * @param value
     *            actual value of the sample. The array may contain zero, one,
     *            or more elements. For an interpolated sample, this typically
     *            is the (element-wise) mean of the aggregated samples' values.
     * @param minimum
     *            minimum value. For an interpolated sample, this is typically
     *            the smallest value that any of the aggregated samples had.
     * @param maximum
     *            maximum value. For an interpolated sample, this is typically
     *            the largest value that any of the aggregated samples had.
     * @param severity
     *            alarm severity associated with the sample.
     * @param hasValue
     *            <code>true</code> if the sample has a (valid) value,
     *            <code>false</code> if the value should be ignored (possibly
     *            because it is invalid).
     * @param status
     *            status of the sample. Typically, this string contains
     *            additional information about the alarm conditions that were
     *            present when the sample was archived.
     * @param quality
     *            quality of the sample. The quality specifies whether the
     *            sample was retrieved directly from the control-system or
     *            whether it was calculated by aggregating the samples for a
     *            certain period of time.
     * @param precision
     *            display precision of the sample's value. The precision
     *            specifies the number of fractional digits that should be
     *            displayed.
     * @param units
     *            engineering units of the sample's value.
     * @param displayLow
     *            lower display limit for the sample's value.
     * @param displayHigh
     *            upper display limit for the sample's value.
     * @param warnLow
     *            lower warning limit for the sample's value. Typically, this is
     *            the limit below which the process variable is considered to be
     *            in a minor alarm condition.
     * @param warnHigh
     *            upper warning limit for the sample's value. Typically, this is
     *            the limit above which the process variable is considered to be
     *            in a minor alarm condition.
     * @param alarmLow
     *            lower alarm limit for the sample's value. Typically, this is
     *            the limit below which the process variable is considered to be
     *            in a major alarm condition.
     * @param alarmHigh
     *            upper alarm limit for the sample's value. Typically, this is
     *            the limit above which the process variable is considered to be
     *            in a major alarm condition.
     * @throws IOException
     *             if the <code>jsonGenerator</code> throws such an exception.
     */
    public static void serializeMinMaxDoubleSample(JsonGenerator jsonGenerator,
            long timeStamp, double[] value, double minimum, double maximum,
            Severity severity, boolean hasValue, String status,
            Quality quality, int precision, String units, double displayLow,
            double displayHigh, double warnLow, double warnHigh,
            double alarmLow, double alarmHigh) throws IOException {
        writeCommonMetaData(jsonGenerator, timeStamp, severity, hasValue,
                status, quality);
        writeNumericMetaData(jsonGenerator, precision, units, displayLow,
                displayHigh, warnLow, warnHigh, alarmLow, alarmHigh);
        writeDoubleValue(jsonGenerator, value, "minMaxDouble");
        writeMinimumMaximum(jsonGenerator, minimum, maximum);
    }

    /**
     * Serializes a scalar (single element) string sample.
     * 
     * @param jsonGenerator
     *            JSON generator to which the serialized data is written.
     * @param timeStamp
     *            time stamp of the sample. The time stamp is specified in
     *            nanoseconds since epoch (January 1st, 1970, 00:00:00 UTC).
     * @param value
     *            actual value of the sample.
     * @param severity
     *            alarm severity associated with the sample.
     * @param hasValue
     *            <code>true</code> if the sample has a (valid) value,
     *            <code>false</code> if the value should be ignored (possibly
     *            because it is invalid).
     * @param status
     *            status of the sample. Typically, this string contains
     *            additional information about the alarm conditions that were
     *            present when the sample was archived.
     * @param quality
     *            quality of the sample. The quality specifies whether the
     *            sample was retrieved directly from the control-system or
     *            whether it was calculated by aggregating the samples for a
     *            certain period of time.
     * @throws IOException
     *             if the <code>jsonGenerator</code> throws such an exception.
     */
    public static void serializeStringSample(JsonGenerator jsonGenerator,
            long timeStamp, String value, Severity severity, boolean hasValue,
            String status, Quality quality) throws IOException {
        writeCommonMetaData(jsonGenerator, timeStamp, severity, hasValue,
                status, quality);
        writeStringValue(jsonGenerator, value);
    }

    /**
     * Serializes an array string sample.
     * 
     * @param jsonGenerator
     *            JSON generator to which the serialized data is written.
     * @param timeStamp
     *            time stamp of the sample. The time stamp is specified in
     *            nanoseconds since epoch (January 1st, 1970, 00:00:00 UTC).
     * @param value
     *            actual value of the sample. The array may contain zero, one,
     *            or more elements.
     * @param severity
     *            alarm severity associated with the sample.
     * @param hasValue
     *            <code>true</code> if the sample has a (valid) value,
     *            <code>false</code> if the value should be ignored (possibly
     *            because it is invalid).
     * @param status
     *            status of the sample. Typically, this string contains
     *            additional information about the alarm conditions that were
     *            present when the sample was archived.
     * @param quality
     *            quality of the sample. The quality specifies whether the
     *            sample was retrieved directly from the control-system or
     *            whether it was calculated by aggregating the samples for a
     *            certain period of time.
     * @throws IOException
     *             if the <code>jsonGenerator</code> throws such an exception.
     */
    public static void serializeStringSample(JsonGenerator jsonGenerator,
            long timeStamp, String[] value, Severity severity,
            boolean hasValue, String status, Quality quality)
            throws IOException {
        writeCommonMetaData(jsonGenerator, timeStamp, severity, hasValue,
                status, quality);
        writeStringValue(jsonGenerator, value);
    }

    private static void writeCommonMetaData(JsonGenerator jsonGenerator,
            long timeStamp, Severity severity, boolean hasValue, String status,
            Quality quality) throws IOException {
        writeTimeStamp(jsonGenerator, timeStamp);
        writeSeverity(jsonGenerator, severity, hasValue);
        writeStatus(jsonGenerator, status);
        writeQuality(jsonGenerator, quality);
    }

    private static void writeDoubleValue(JsonGenerator jsonGenerator,
            double value, String type) throws IOException {
        writeType(jsonGenerator, type);
        jsonGenerator.writeFieldName("value");
        jsonGenerator.writeStartArray();
        jsonGenerator.writeNumber(value);
        jsonGenerator.writeEndArray();
    }

    private static void writeDoubleValue(JsonGenerator jsonGenerator,
            double[] value, String type) throws IOException {
        writeType(jsonGenerator, type);
        jsonGenerator.writeFieldName("value");
        jsonGenerator.writeStartArray();
        for (int i = 0; i < value.length; ++i) {
            jsonGenerator.writeNumber(value[i]);
        }
        jsonGenerator.writeEndArray();
    }

    private static void writeEnumMetaData(JsonGenerator jsonGenerator,
            String[] states) throws IOException {
        jsonGenerator.writeFieldName("metaData");
        jsonGenerator.writeStartObject();
        jsonGenerator.writeStringField("type", "enum");
        jsonGenerator.writeFieldName("states");
        jsonGenerator.writeStartArray();
        for (String state : states) {
            jsonGenerator.writeString(state);
        }
        jsonGenerator.writeEndArray();
        jsonGenerator.writeEndObject();
    }

    private static void writeEnumValue(JsonGenerator jsonGenerator, int value)
            throws IOException {
        writeType(jsonGenerator, "enum");
        jsonGenerator.writeFieldName("value");
        jsonGenerator.writeStartArray();
        jsonGenerator.writeNumber(value);
        jsonGenerator.writeEndArray();
    }

    private static void writeEnumValue(JsonGenerator jsonGenerator, int[] value)
            throws IOException {
        writeType(jsonGenerator, "enum");
        jsonGenerator.writeFieldName("value");
        jsonGenerator.writeStartArray();
        for (int i = 0; i < value.length; ++i) {
            jsonGenerator.writeNumber(value[i]);
        }
        jsonGenerator.writeEndArray();
    }

    private static void writeLongValue(JsonGenerator jsonGenerator, long value)
            throws IOException {
        writeType(jsonGenerator, "long");
        jsonGenerator.writeFieldName("value");
        jsonGenerator.writeStartArray();
        jsonGenerator.writeNumber(value);
        jsonGenerator.writeEndArray();
    }

    private static void writeLongValue(JsonGenerator jsonGenerator, long[] value)
            throws IOException {
        writeType(jsonGenerator, "long");
        jsonGenerator.writeFieldName("value");
        jsonGenerator.writeStartArray();
        for (int i = 0; i < value.length; ++i) {
            jsonGenerator.writeNumber(value[i]);
        }
        jsonGenerator.writeEndArray();
    }

    private static void writeMinimumMaximum(JsonGenerator jsonGenerator,
            double minimum, double maximum) throws IOException {
        jsonGenerator.writeNumberField("minimum", minimum);
        jsonGenerator.writeNumberField("maximum", maximum);
    }

    private static void writeNumericMetaData(JsonGenerator jsonGenerator,
            int precision, String units, double displayLow, double displayHigh,
            double warnLow, double warnHigh, double alarmLow, double alarmHigh)
            throws IOException {
        jsonGenerator.writeFieldName("metaData");
        jsonGenerator.writeStartObject();
        jsonGenerator.writeStringField("type", "numeric");
        jsonGenerator.writeNumberField("precision", precision);
        jsonGenerator.writeStringField("units", units);
        jsonGenerator.writeNumberField("displayLow", displayLow);
        jsonGenerator.writeNumberField("displayHigh", displayHigh);
        jsonGenerator.writeNumberField("warnLow", warnLow);
        jsonGenerator.writeNumberField("warnHigh", warnHigh);
        jsonGenerator.writeNumberField("alarmLow", alarmLow);
        jsonGenerator.writeNumberField("alarmHigh", alarmHigh);
        jsonGenerator.writeEndObject();
    }

    private static void writeQuality(JsonGenerator jsonGenerator,
            Quality quality) throws IOException {
        switch (quality) {
        case ORIGINAL:
            jsonGenerator.writeStringField("quality", "Original");
            break;
        case INTERPOLATED:
            jsonGenerator.writeStringField("quality", "Interpolated");
            break;
        default:
            throw new RuntimeException("Unhandled quality: " + quality);
        }
    }

    private static void writeSeverity(JsonGenerator jsonGenerator,
            Severity severity, boolean hasValue) throws IOException {
        jsonGenerator.writeFieldName("severity");
        jsonGenerator.writeStartObject();
        switch (severity) {
        case OK:
            jsonGenerator.writeStringField("level", "OK");
            break;
        case MINOR:
            jsonGenerator.writeStringField("level", "MINOR");
            break;
        case MAJOR:
            jsonGenerator.writeStringField("level", "MAJOR");
            break;
        case INVALID:
            jsonGenerator.writeStringField("level", "INVALID");
            break;
        default:
            throw new RuntimeException("Unhandled severity: " + severity);
        }
        jsonGenerator.writeBooleanField("hasValue", hasValue);
        jsonGenerator.writeEndObject();
    }

    private static void writeStatus(JsonGenerator jsonGenerator, String status)
            throws IOException {
        jsonGenerator.writeStringField("status", status);
    }

    private static void writeStringValue(JsonGenerator jsonGenerator,
            String value) throws IOException {
        writeType(jsonGenerator, "string");
        jsonGenerator.writeFieldName("value");
        jsonGenerator.writeStartArray();
        jsonGenerator.writeString(value);
        jsonGenerator.writeEndArray();
    }

    private static void writeStringValue(JsonGenerator jsonGenerator,
            String[] value) throws IOException {
        writeType(jsonGenerator, "string");
        jsonGenerator.writeFieldName("value");
        jsonGenerator.writeStartArray();
        for (int i = 0; i < value.length; ++i) {
            jsonGenerator.writeString(value[i]);
        }
        jsonGenerator.writeEndArray();
    }

    private static void writeTimeStamp(JsonGenerator jsonGenerator,
            long timeStamp) throws IOException {
        jsonGenerator.writeNumberField("time", timeStamp);
    }

    private static void writeType(JsonGenerator jsonGenerator, String type)
            throws IOException {
        jsonGenerator.writeStringField("type", type);
    }

}
