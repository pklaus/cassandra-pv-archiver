/*
 * Copyright 2016 aquenos GmbH.
 * All rights reserved.
 * 
 * This program and the accompanying materials are made available under the 
 * terms of the Eclipse Public License v1.0 which accompanies this distribution,
 * and is available at http://www.eclipse.org/legal/epl-v10.html.
 */

package com.aquenos.cassandra.pvarchiver.server.controlsystem.test;

import java.io.IOException;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.NavigableMap;
import java.util.TreeMap;

import com.aquenos.cassandra.pvarchiver.common.ObjectResultSet;
import com.aquenos.cassandra.pvarchiver.common.SimpleObjectResultSet;
import com.aquenos.cassandra.pvarchiver.controlsystem.ControlSystemChannel;
import com.aquenos.cassandra.pvarchiver.controlsystem.ControlSystemSupport;
import com.aquenos.cassandra.pvarchiver.controlsystem.Sample;
import com.aquenos.cassandra.pvarchiver.controlsystem.SampleBucketId;
import com.aquenos.cassandra.pvarchiver.controlsystem.SampleBucketState;
import com.aquenos.cassandra.pvarchiver.controlsystem.SampleDecimator;
import com.aquenos.cassandra.pvarchiver.controlsystem.SampleListener;
import com.aquenos.cassandra.pvarchiver.controlsystem.SampleWithSizeEstimate;
import com.fasterxml.jackson.core.JsonGenerator;
import com.google.common.collect.Iterators;
import com.google.common.util.concurrent.Futures;
import com.google.common.util.concurrent.ListenableFuture;

/**
 * Stub implementation of the {@link ControlSystemSupport} interface. This
 * implementation only implements read access to samples and not creating
 * channels or writing samples. Unimplemented methods throw an
 * {@link UnsupportedOperationException}.
 * 
 * @author Sebastian Marsching
 * 
 * @param <SampleType>
 *            type that is implemented by all samples that are generated by this
 *            control-system support.
 */
public class ControlSystemSupportStubImpl<SampleType extends Sample> implements
        ControlSystemSupport<SampleType> {

    private Map<SampleBucketId, NavigableMap<Long, SampleType>> sampleBuckets;

    /**
     * Creates a control-system support stub which returns the specified samples
     * when being queried.
     * 
     * @param sampleBuckets
     *            samples that shall be returned by this control-system support.
     *            The keys of this map are the sample-bucket IDs. The values are
     *            the samples stored in this sample bucket.
     */
    public ControlSystemSupportStubImpl(
            Map<SampleBucketId, ? extends Collection<SampleType>> sampleBuckets) {
        this.sampleBuckets = new HashMap<SampleBucketId, NavigableMap<Long, SampleType>>();
        for (Map.Entry<SampleBucketId, ? extends Collection<SampleType>> sampleBucketEntry : sampleBuckets
                .entrySet()) {
            NavigableMap<Long, SampleType> sampleBucket = new TreeMap<Long, SampleType>();
            for (SampleType sample : sampleBucketEntry.getValue()) {
                sampleBucket.put(sample.getTimeStamp(), sample);
            }
            this.sampleBuckets.put(sampleBucketEntry.getKey(), sampleBucket);
        }
    }

    @Override
    public ListenableFuture<? extends ControlSystemChannel> createChannel(
            String channelName, Map<String, String> options,
            SampleBucketId currentBucketId,
            SampleListener<SampleType> sampleListener) {
        throw new UnsupportedOperationException();
    }

    @Override
    public SampleDecimator<SampleType> createSampleDecimator(
            String channelName, Map<String, String> options,
            long intervalStartTime, long intervalLength) {
        throw new UnsupportedOperationException();
    }

    @Override
    public ListenableFuture<Void> deleteSamples(SampleBucketId bucketId) {
        throw new UnsupportedOperationException();
    }

    @Override
    public void destroy() {
        // Nothing to be done here.
    }

    @Override
    public ListenableFuture<SampleWithSizeEstimate<SampleType>> generateChannelDisabledSample(
            String channelName, Map<String, String> options,
            SampleBucketId currentBucketId) {
        throw new UnsupportedOperationException();
    }

    @Override
    public String getId() {
        return "test";
    }

    @Override
    public String getName() {
        return "Test Stub Control System";
    }

    @Override
    public ListenableFuture<SampleBucketState> getSampleBucketState(
            SampleBucketId bucketId) {
        throw new UnsupportedOperationException();
    }

    @Override
    public ListenableFuture<ObjectResultSet<SampleType>> getSamples(
            SampleBucketId bucketId, long timeStampGreaterThanOrEqualTo,
            long timeStampLessThanOrEqualTo, int limit) {
        NavigableMap<Long, SampleType> sampleBucket = sampleBuckets
                .get(bucketId);
        if (sampleBucket == null) {
            return Futures
                    .<ObjectResultSet<SampleType>> immediateFuture(SimpleObjectResultSet
                            .<SampleType> fromIterator(null));
        }
        NavigableMap<Long, SampleType> selectedSamples = sampleBucket.subMap(
                timeStampGreaterThanOrEqualTo, true,
                timeStampLessThanOrEqualTo, true);
        Iterator<SampleType> sampleIterator = selectedSamples.values()
                .iterator();
        if (limit >= 0) {
            sampleIterator = Iterators.limit(sampleIterator, limit);
        }
        return Futures
                .<ObjectResultSet<SampleType>> immediateFuture(SimpleObjectResultSet
                        .fromIterator(sampleIterator));
    }

    @Override
    public ListenableFuture<ObjectResultSet<SampleType>> getSamplesInReverseOrder(
            SampleBucketId bucketId, long timeStampGreaterThanOrEqualTo,
            long timeStampLessThanOrEqualTo, int limit) {
        NavigableMap<Long, SampleType> sampleBucket = sampleBuckets
                .get(bucketId);
        if (sampleBucket == null) {
            return Futures
                    .<ObjectResultSet<SampleType>> immediateFuture(SimpleObjectResultSet
                            .<SampleType> fromIterator(null));
        }
        NavigableMap<Long, SampleType> selectedSamples = sampleBucket.subMap(
                timeStampGreaterThanOrEqualTo, true,
                timeStampLessThanOrEqualTo, true).descendingMap();
        Iterator<SampleType> sampleIterator = selectedSamples.values()
                .iterator();
        if (limit >= 0) {
            sampleIterator = Iterators.limit(sampleIterator, limit);
        }
        return Futures
                .<ObjectResultSet<SampleType>> immediateFuture(SimpleObjectResultSet
                        .fromIterator(sampleIterator));
    }

    @Override
    public void serializeSampleToJsonV1(SampleType sample,
            JsonGenerator jsonGenerator) throws IOException {
        throw new UnsupportedOperationException();
    }

    @Override
    public ListenableFuture<Void> writeSample(SampleType sample,
            SampleBucketId bucketId, int newBucketSize) {
        throw new UnsupportedOperationException();
    }

}
