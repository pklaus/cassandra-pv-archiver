/*
 * Copyright 2015-2016 aquenos GmbH.
 * All rights reserved.
 * 
 * This program and the accompanying materials are made available under the 
 * terms of the Eclipse Public License v1.0 which accompanies this distribution,
 * and is available at http://www.eclipse.org/legal/epl-v10.html.
 */

package com.aquenos.cassandra.pvarchiver.server.web.common.spring;

import java.util.Locale;

import nz.net.ultraq.thymeleaf.LayoutDialect;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ResourceLoaderAware;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.io.ResourceLoader;
import org.thymeleaf.extras.springsecurity4.dialect.SpringSecurityDialect;
import org.thymeleaf.spring4.SpringTemplateEngine;
import org.thymeleaf.spring4.templateresolver.SpringResourceTemplateResolver;
import org.thymeleaf.spring4.view.ThymeleafViewResolver;
import org.thymeleaf.templatemode.TemplateMode;
import org.thymeleaf.templateresolver.ITemplateResolver;

import com.aquenos.cassandra.pvarchiver.server.spring.DevelopmentModeProperties;

/**
 * Configuration for using Thymeleaf with Spring Web MVC. This configuration
 * sets up the {@link ThymeleafViewResolver} and auxiliary components needed by
 * Thymeleaf.
 * 
 * @author Sebastian Marsching
 *
 */
@Configuration
public class ThymeleafConfiguration implements ResourceLoaderAware {

    private DevelopmentModeProperties developmentProperties;
    private ResourceLoader resourceLoader;

    /**
     * Sets the development-mode properties used by this configuration.
     * Typically, this method is called by the container.
     * 
     * @param developmentModeProperties
     *            development-mode properties to be used by this configuration.
     */
    @Autowired
    public void setDevelopmentModeProperties(
            DevelopmentModeProperties developmentModeProperties) {
        this.developmentProperties = developmentModeProperties;
    }

    /**
     * Tells whether templates should be cached. The default implementation
     * decides to cache templates when running in production mode (
     * {@link DevelopmentModeProperties#isEnabled()} returns <code>false</code>
     * ).
     * 
     * @return <code>true</code> if templates should be cached,
     *         <code>false</code> if they should be checked for changes on every
     *         request.
     */
    protected boolean isCacheTemplates() {
        return !developmentProperties.isEnabled();
    }

    /**
     * Returns the prefix prepended to template names in order to find the
     * resource storing the template. The default implementation returns a
     * prefix of <code>classpath:/META-INF/templates/</code>
     * 
     * @return prefix used for template name resolution.
     */
    protected String getTemplatePrefix() {
        return "classpath:/META-INF/templates/";
    }

    /**
     * Returns the suffix appended to template names in order to find the
     * resource storing the template. The default implementation returns a
     * suffix of <code>.html</code>.
     * 
     * @return suffix used for template name resolution.
     */
    protected String getTemplateSuffix() {
        return ".html";
    }

    /**
     * Returns the template mode used by Thymeleaf when processing templates.
     * The template mode determines which kind of output is generated (HTML,
     * XHTML). The default implementation returns <code>HTML5</code> to produce
     * HTML5 output.
     * 
     * @return template mode to be used by Thymeleaf when processing templates.
     *         This must be one of the strings supported by the Thymeleaf
     *         template engine.
     */
    protected TemplateMode getTemplateMode() {
        return TemplateMode.HTML;
    }

    /**
     * Returns the character encoding used for template files. The default
     * implementation returns <code>UTF-8</code>.
     * 
     * @return character encoding used for template files.
     */
    protected String getTemplateCharacterEncoding() {
        return "UTF-8";
    }

    /**
     * Returns the character encoding used for the output generated by the
     * template engine. The default implementation returns <code>UTF-8</code>.
     * When overriding this method, one should also override
     * {@link #getViewContentType()}.
     * 
     * @return character encoding used for the output generated by the template
     *         engine.
     */
    protected String getViewCharacterEncoding() {
        return "UTF-8";
    }

    /**
     * Returns the content type associated with the output generated by the
     * template engine. This is the content type that is typically indicated in
     * the header of an HTTP response. This should include the charset
     * information. The default implementation returns
     * "text/html;charset=UTF-8". When overriding this method, one might also
     * have to override {@link #getViewCharacterEncoding()}.
     * 
     * @return content type of the output generated by the template engine.
     */
    protected String getViewContentType() {
        return "text/html;charset=UTF-8";
    }

    /**
     * Configures the (non-standard) dialects that are supported by the template
     * engine. This method is called by {@link #thymeleafTemplateEngine()} after
     * creating the template engine. The default implementation adds the layout
     * dialect, the Spring Security dialect, and the URI expander dialect.
     * 
     * @param templateEngine
     *            template engine to which dialects can be added.
     */
    protected void configureDialects(SpringTemplateEngine templateEngine) {
        templateEngine.addDialect(thymeleafLayoutDialect());
        templateEngine.addDialect(thymeleafSpringSecurityDialect());
        templateEngine.addDialect(thymeleafUriExpanderDialect());
    }

    /**
     * Creates the template resolver used by Thymeleaf to resolve template
     * names. This template resolver is configured with the parameters returned
     * by {@link #getTemplatePrefix()}, {@link #getTemplateSuffix()},
     * {@link #getTemplateMode()}, {@link #getTemplateCharacterEncoding()}, and
     * {@link #isCacheTemplates()}.
     * 
     * @return template resolved used by Thymeleaf.
     */
    @Bean
    public ITemplateResolver thymeleafTemplateResolver() {
        SpringResourceTemplateResolver resolver = new SpringResourceTemplateResolver();
        resolver.setPrefix(getTemplatePrefix());
        resolver.setSuffix(getTemplateSuffix());
        resolver.setTemplateMode(getTemplateMode());
        resolver.setCharacterEncoding(getTemplateCharacterEncoding());
        resolver.setCacheable(isCacheTemplates());
        return resolver;
    }

    /**
     * Creates the Thymeleaf template engine. This is the engine that is used by
     * the {@link #thymeleafViewResolver()}. The template engine is configured
     * to use the {@link #thymeleafTemplateResolver()} and subsequently passed
     * on to {@link #configureDialects(SpringTemplateEngine)}.
     * 
     * @return Thymeleaf template engine.
     */
    @Bean
    public SpringTemplateEngine thymeleafTemplateEngine() {
        SpringTemplateEngine engine = new SpringTemplateEngine();
        engine.addTemplateResolver(thymeleafTemplateResolver());
        configureDialects(engine);
        return engine;
    }

    /**
     * Creates the Thymeleaf layout dialect. This dialect is added to the
     * template engine by {@link #configureDialects(SpringTemplateEngine)}.
     * 
     * @return Thymeleaf layout dialect.
     */
    @Bean
    public LayoutDialect thymeleafLayoutDialect() {
        return new LayoutDialect();
    }

    /**
     * Creates the Thymeleaf Spring Security dialect. This dialect is added to
     * the template engine by {@link #configureDialects(SpringTemplateEngine)}.
     * 
     * @return Thymeleaf Spring Security dialect.
     */
    @Bean
    public SpringSecurityDialect thymeleafSpringSecurityDialect() {
        return new SpringSecurityDialect();
    }

    /**
     * Creates the Thymeleaf URI expander dialect. This dialect is added to the
     * template engine by {@link #configureDialects(SpringTemplateEngine)}.
     * 
     * @return Thymeleaf URI expander dialect.
     */
    @Bean
    public UriExpanderDialect thymeleafUriExpanderDialect() {
        return new UriExpanderDialect();
    }

    /**
     * Creates the Thymeleaf view resolver. This view resolver is configured to
     * use the template engine returned by {@link #thymeleafTemplateEngine()}
     * and use the character encoding and content type provided by
     * {@link #getViewCharacterEncoding()} and {@link #getViewContentType()}.
     * This implementation used a modified version of
     * {@link ThymeleafViewResolver} that only handles a view name when the
     * corresponding template file exists. This makes it possible to use the
     * view resolver together with other view resolvers that come later in the
     * chain.
     * 
     * @return view resolver that creates views using the Thymeleaf template
     *         engine.
     */
    @Bean
    public ThymeleafViewResolver thymeleafViewResolver() {
        ThymeleafViewResolver resolver = new ThymeleafViewResolver() {

            @Override
            protected boolean canHandle(String viewName, Locale locale) {
                // We know how templates are resolved, therefore we can take a
                // shortcut in order to check whether a view can be resolved.
                return resourceLoader.getResource(
                        getTemplatePrefix() + viewName + getTemplateSuffix())
                        .exists();
            }
        };
        resolver.setTemplateEngine(thymeleafTemplateEngine());
        resolver.setCharacterEncoding(getViewCharacterEncoding());
        resolver.setContentType(getViewContentType());
        return resolver;
    }

    @Override
    public void setResourceLoader(ResourceLoader resourceLoader) {
        this.resourceLoader = resourceLoader;
    }

}
