/*
 * Copyright 2016 aquenos GmbH.
 * All rights reserved.
 * 
 * This program and the accompanying materials are made available under the 
 * terms of the Eclipse Public License v1.0 which accompanies this distribution,
 * and is available at http://www.eclipse.org/legal/epl-v10.html.
 */

package com.aquenos.cassandra.pvarchiver.common;

import java.nio.charset.Charset;
import java.nio.charset.IllegalCharsetNameException;
import java.nio.charset.UnsupportedCharsetException;

/**
 * <p>
 * Utility for encoding and decoding strings so that they can safely be used as
 * part of a URL.
 * </p>
 * 
 * <p>
 * This utility can be used to encode a string that shall be used as part of a
 * URL. After encoding, the string does not contain any characters that carry a
 * special meaning in a URL path or query string.
 * </p>
 * 
 * <p>
 * When being encoded, a string is first converted to its byte representation.
 * Then, only the letters <code>A</code>&#8211;<code>Z</code> and <code>a</code>
 * &#8211;<code>z</code>, the digits <code>0</code>&#8211;<code>9</code>, the
 * minus sign (<code>-</code>), and the underscore (<code>_</code>) are kept as
 * is.
 * </p>
 * 
 * <p>
 * All other bytes are encoded in the resulting string by a tilde character(
 * <code>~</code>) followed by two hexadecimal digits.
 * </p>
 * 
 * <p>
 * The encoding used by this class is very similar to the general encoding used
 * for URLs, but there are a few important differences:
 * </p>
 * 
 * <ul>
 * <li>Instead of the percent character (<code>%</code>), the tilde character (
 * <code>~</code>) is used for escaping. This has the advantage that no
 * double-escaping will occur if the encoded string is used as part of a URL
 * that is then encoded again.</li>
 * <li>It encodes characters that are valid in a URL path (or query string), but
 * might carry a special meaning. In particular, forward slashes (<code>/</code>
 * ) and the semicolon (<code>;</code>) are encoded. This way, encoded strings
 * can safely be used as part of a URL path.</li>
 * <li>As the encoding scheme is incompatible with the regular URL encoding,
 * string encoded using this encoding will never be interpreted or partially
 * decoded by a web server. This way, it is possible to pass a string containing
 * special characters between different applications without having any
 * undesired conversions in between.</li>
 * </ul>
 * 
 * <p>
 * When decoding, this utility assumes that the encoded string only contains
 * characters from the US-ASCII character set (like a correctly encoded string
 * does). Other characters are mostly likely lost during the decoding process.
 * </p>
 * 
 * @author Sebastian Marsching
 */
public abstract class CustomUrlCodec {

    private static final Charset CHARSET_ASCII = Charset.forName("US-ASCII");
    private static final Charset CHARSET_UTF8 = Charset.forName("UTF-8");
    private static final char[] HEX_DIGITS = { '0', '1', '2', '3', '4', '5',
            '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };

    private static final boolean[] IS_ALLOWED_CHARACTER;

    static {
        IS_ALLOWED_CHARACTER = new boolean[256];
        // Allow -
        IS_ALLOWED_CHARACTER[0x2d] = true;
        // Allow digits 0 to 9
        for (int i = 0x30; i <= 0x39; ++i) {
            IS_ALLOWED_CHARACTER[i] = true;
        }
        // Allow letters A to Z
        for (int i = 0x41; i <= 0x5a; ++i) {
            IS_ALLOWED_CHARACTER[i] = true;
        }
        // Allow _
        IS_ALLOWED_CHARACTER[0x5f] = true;
        // Allow letters a to z
        for (int i = 0x61; i <= 0x7a; ++i) {
            IS_ALLOWED_CHARACTER[i] = true;
        }
    }

    private static final boolean[] IS_HEX_DIGIT;

    static {
        IS_HEX_DIGIT = new boolean[256];
        // Allow digits 0 to 9
        for (int i = 0x30; i <= 0x39; ++i) {
            IS_HEX_DIGIT[i] = true;
        }
        // Allow letters A to F
        for (int i = 0x41; i <= 0x46; ++i) {
            IS_HEX_DIGIT[i] = true;
        }
        // Allow letters a to f
        for (int i = 0x61; i <= 0x66; ++i) {
            IS_HEX_DIGIT[i] = true;
        }
    }

    /**
     * Decodes an encoded string using the UTF-8 character set. The decoding is
     * performed according to the rules described in the documentation of this
     * class.
     * 
     * @param encodedString
     *            encoded string. Typically, this string will have been
     *            generated by calling the {@link #encode(String)} method.
     * @return decoded string.
     * @see #decode(String, Charset)
     * @see #encode(String)
     * @throws NullPointerException
     *             if <code>encodedString</code> is <code>null</code>.
     */
    public static String decode(String encodedString) {
        return decode(encodedString, CHARSET_UTF8);
    }

    /**
     * Decodes an encoded string using the specified encoding. The decoding is
     * performed according to the rules described in the documentation of this
     * class. The specified encoding is used to convert the byte array that is
     * the result of the decoding process back to a string.
     * 
     * @param encodedString
     *            encoded string. Typically, this string will have been
     *            generated by calling the {@link #encode(String, String)}
     *            method, using the same <code>encoding</code>.
     * @param encoding
     *            encoding that is used for converting the resulting byte array
     *            back to a string (e.g. &quot;UTF-8&quot;).
     * @return decoded string.
     * @throws IllegalArgumentException
     *             if <code>encoding</code> is <code>null</code>.
     * @throws IllegalCharsetNameException
     *             if the specified <code>encoding</code> is not valid.
     * @throws NullPointerException
     *             if <code>encodedString</code> is <code>null</code>.
     * @throws UnsupportedCharsetException
     *             if the specified <code>encoding</code> is not supported by
     *             the JVM.
     * @see #decode(String, Charset)
     * @see #encode(String, String)
     */
    public static String decode(String encodedString, String encoding) {
        return decode(encodedString, Charset.forName(encoding));
    }

    /**
     * Decodes an encoded string using the specified character set. The decoding
     * is performed according to the rules described in the documentation of
     * this class. The specified character set is used to convert the byte array
     * that is the result of the decoding process back to a string.
     * 
     * @param encodedString
     *            encoded string. Typically, this string will have been
     *            generated by calling the {@link #encode(String, Charset)}
     *            method, using the same <code>charset</code>.
     * @param charset
     *            character set that is used for converting the resulting byte
     *            array back to a string.
     * @return decoded string.
     * @throws NullPointerException
     *             if <code>charset</code> or <code>encodedString</code> is
     *             <code>null</code>.
     * @see #encode(String, Charset)
     */
    public static String decode(String encodedString, Charset charset) {
        // We first convert the string to an byte array using the US-ASCII
        // charset. If the string is a valid encoded string, this should work
        // because after encoding, it can only contain characters from the
        // US-ASCII charset. If it is not a valid string, this will remove any
        // invalid characters.
        byte[] encodedBytes = encodedString.getBytes(CHARSET_ASCII);
        byte[] decodedBytes = new byte[encodedBytes.length];
        int decodedBytesLength = 0;
        for (int i = 0; i < encodedBytes.length; ++i) {
            int c = encodedBytes[i] & 0xff;
            switch (c) {
            case '~':
                // If this is a properly encoded string, there must be two hex
                // digits after the tilde. If there are not, the string is
                // invalid. However, instead of throwing an exception, we simply
                // copy the bytes as they are.
                if (i + 2 < encodedBytes.length) {
                    int c1 = encodedBytes[i + 1] & 0xff;
                    int c2 = encodedBytes[i + 2] & 0xff;
                    if (IS_HEX_DIGIT[c1] && IS_HEX_DIGIT[c2]) {
                        int d1 = Character.digit(c1, 16);
                        int d2 = Character.digit(c2, 16);
                        decodedBytes[decodedBytesLength] = (byte) ((d1 << 4) | d2);
                        ++decodedBytesLength;
                        i += 2;
                    } else {
                        decodedBytes[decodedBytesLength] = (byte) c;
                        ++decodedBytesLength;
                    }
                } else {
                    decodedBytes[decodedBytesLength] = (byte) c;
                    ++decodedBytesLength;
                }
                break;
            default:
                decodedBytes[decodedBytesLength] = (byte) c;
                ++decodedBytesLength;
                break;
            }
        }
        return new String(decodedBytes, 0, decodedBytesLength, charset);
    }

    /**
     * Encodes the specified string using the UTF-8 character set. The encoding
     * is performed according to the rules described in the documentation of
     * this class.
     * 
     * @param unencodedString
     *            string to be encoded.
     * @return encoded string. The encoded string is suitable for decoding by
     *         {@link #decode(String)}.
     * @throws NullPointerException
     *             if <code>unencodedString</code> is <code>null</code>.
     * @see #decode(String)
     * @see #encode(String, Charset)
     */
    public static String encode(String unencodedString) {
        return encode(unencodedString, CHARSET_UTF8);
    }

    /**
     * Encodes the specified string using the specified encoding. The encoding
     * is performed according to the rules described in the documentation of
     * this class. The specified encoding is used to convert the string to a
     * byte array before encoding it.
     * 
     * @param unencodedString
     *            string to be encoded.
     * @param encoding
     *            encoding that is used for converting the string to a byte
     *            array (e.g. &quot;UTF-8&quot;).
     * @return encoded string. The encoded string is suitable for decoding by
     *         {@link #decode(String, String)}.
     * @throws IllegalArgumentException
     *             if <code>encoding</code> is <code>null</code>.
     * @throws IllegalCharsetNameException
     *             if the specified <code>encoding</code> is not valid.
     * @throws NullPointerException
     *             if <code>unencodedString</code> is <code>null</code>.
     * @throws UnsupportedCharsetException
     *             if the specified <code>encoding</code> is not supported by
     *             the JVM.
     * @see #decode(String, String)
     * @see #encode(String, Charset)
     */
    public static String encode(String unencodedString, String encoding) {
        return encode(unencodedString, Charset.forName(encoding));
    }

    /**
     * Encoded the specified string using the specified character set. The
     * encoding is performed according to the rules described in the
     * documentation of this class. The specified character set is used to
     * convert the string to byte array before encoding it.
     * 
     * @param unencodedString
     *            string to be encoded.
     * @param charset
     *            character set that is used for converting the string to a byte
     *            array.
     * @return encoded string. The encoded string is suitable for decoding by
     *         {@link #decode(String, Charset)}.
     * @throws NullPointerException
     *             if <code>charset</code> or <code>unencodedString</code> is
     *             <code>null</code>.
     * @see #decode(String, Charset)
     */
    public static String encode(String unencodedString, Charset charset) {
        byte[] unencodedBytes = unencodedString.getBytes(charset);
        StringBuilder sb = new StringBuilder(unencodedBytes.length);
        for (int i = 0; i < unencodedBytes.length; ++i) {
            int c = unencodedBytes[i] & 0xff;
            if (IS_ALLOWED_CHARACTER[c]) {
                sb.append((char) c);
            } else {
                sb.append('~');
                sb.append(HEX_DIGITS[c >>> 4]);
                sb.append(HEX_DIGITS[c & 0x0f]);
            }
        }
        return sb.toString();
    }

}
